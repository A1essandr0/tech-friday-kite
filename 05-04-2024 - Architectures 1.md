# Kite TF 5.04.2024 - Architectures 1

Приложение как один процесс ОС (упрощенно). 

Информационная система как множество приложений на множестве машин.

Архитектурные стили - наиболее высокий уровень абстракции

- Слоеная архитектура (layered)
- Ядро и плагины (microkernel)
- Основанная на событиях (event-driven)
- (Микро)сервисная (service-oriented)
- …

Легко могут сочетаться и переплетаться.

Марк Ричардс

[https://systems.education/software-architecture-patterns](https://systems.education/software-architecture-patterns) (русский перевод 1го издания)

[https://ae.oreilly.com/l/1009792/2023-05-26/gw54/1009792/1685141235Z8bRQIn3/Software_Architecture_Patterns.pdf](https://ae.oreilly.com/l/1009792/2023-05-26/gw54/1009792/1685141235Z8bRQIn3/Software_Architecture_Patterns.pdf) (2е издание)

---

Архитектурные паттерны - способы реализации стиля. Обычно они призваны решить какую-то конкретную проблему.

Например, по мере нарастания сложности системы мы должны каким-то образом  структурировать код, уменьшая связность (coupling) модулей, просто для того, чтобы не сойти с ума (т.е. быть способным удержать весь контекст в одной голове).

![Untitled](Kite%20TF%205%2004%202024%20-%20Architectures%201%2007291fc29bba43a3ba77b04340b31191/Untitled.png)

Для решения этой проблемы предназначена одна группа паттернов. Например, гексагональная архитектура, она же порты и адаптеры.

Другая проблема - как повысить гибкость и тестируемость модулей? Для этого существует Dependency Injection.

Еще одна проблема - устойчивость приложений. Решаем через несколько инстансов микросервиса. Это может войти в противоречие с другим паттерном, т.к. с его точки зрения лучше не делать отдельный сервис, а работать как корутина внутри того же самого приложения (high cohesion).

---

Порты и адаптеры

![Untitled](Kite%20TF%205%2004%202024%20-%20Architectures%201%2007291fc29bba43a3ba77b04340b31191/Untitled%201.png)

Контроллеры: точки входа в приложение; входные порты, Driving Adapters

- из веба (REST, gRPC)
- из очередей как консюмер (Kafka, AMQP)
- по таймаутам (например, из внутреннего скедулера приложения)
- из CLI (например, администрирование)

Репозитории: инфраструктурные или внешние зависимости; выходные порты, Driven Adapters

- БД
- внешние сервисы
- очереди как паблишер

Изолированный слой бизнес-логики - юзкейсы, которые ничего не знают о конкретных реализациях ни репозиториев, ни контроллеров. Также на этом слое живут сущности (Entities), которые могут быть просто моделями/датаклассами, а могут содержать развернутую логику.

В юзкейсы инжектятся внешние зависимости, сами юзкейсы инжектятся в контроллеры. Обычно через интерфейсы, т.е. инжектится не реализация, а интерфейс (в условиях Питона это ABC или протокол).

Например, вот как можно оформить репозиторий. Инстанс создается через фабрику и протокол, затем инжектится в юзкейс, где будет использован. Мы всегда можем одной строчкой конфига подменить реализацию, например, заменить на мок.

[https://gist.github.com/A1essandr0/0c49ce678f8d3b0721e3558c1f6d5c0b](https://gist.github.com/A1essandr0/0c49ce678f8d3b0721e3558c1f6d5c0b)

Вот другой пример, как происходит цепь инъекций для через все слои (пример на Go)

[https://gist.github.com/A1essandr0/b4b092c1e3f0d27e55d1e971bcf3a80c](https://gist.github.com/A1essandr0/b4b092c1e3f0d27e55d1e971bcf3a80c)

В любой момент мы можем подменить одну реализацию другой, опять же, даже не залезая в код, просто строчкой на уровне конфига.

---

AffsubGenerator

Контроллер AffSubsController обрабатывает афсабы. Он принимает интерфейсы: Store, KafkaClient, WhoisClient, SubsProcessor.

Первые три - внешние зависимости/репозитории, SubsProcessor - это юзкейс. Логика приложения выполняется на и на уровне AffSubsController, и на уровне SubsProcessor, в который для этого инжектится зависимость ConfigStore.

[https://gist.github.com/A1essandr0/2a93845c6a0809d9634a4b94b0fe6505](https://gist.github.com/A1essandr0/2a93845c6a0809d9634a4b94b0fe6505)

Для увеличения гибкости и приведения всего к Clean Architecture хорошо бы убрать из контроллера всю логику в дополнительные юзкейсы AddRecord, SendEvent. Но т.к. логики там немного, можно оставить и так.

В AppContainer можно также инжектить сам инстанс приложения FastAPI - если мы хотим, чтобы параллельно/конкуррентно вебсерверу работало что-то еще.

---

WatchTower

В приложение WatchtowerApi инжектится WebServer.

WebServer создается фабрикой и в него инжектятся контроллеры (EventsController, …), в которые, в свою очередь, инжектятся юзкейсы (EventsUseCase, …), в которые инжектятся репозитории (EventsRepository, …) и др. зависимости.

В результате на уровне контроллеров происходит только валидация данных/обработка ошибок, на уровне юзкейсов сама логика, на уровне репозиториев - детали запросов/ответов из базы.

Также существует логика на уровне методов самих объектов в юзкейсах, можно сказать, что она существует на уровне Entity.

Реально WatchtowerUploader существует как отдельный сервис. Но он вполне мог работать в горутине параллельно WebServer. Между ними нет никакого общения, кроме того, что один читает Events из Клика, а другой туда пишет.

В Uploader инжектится KafkaConsumer, который выполняет роль контроллера для событий из Кафки, в него напрямую инжектятся репозитории (слоя юзкейсов нет, тут события не обрабатываются, а просто складируются в промежуточное хранилище). 

Другая точка входа в приложение - скедулер, который называется UploadsManager, который по мере накопления батча берет объекты из промежуточного хранилища, чуток обрабатывает и складирует в Клик. Тут я тоже решил не создавать слой юзкейсов, а сразу на уровне контроллера/скедулера выполнять небольшую логику. Соответственно, репозитории тоже инжектятся прямо в UploadsManager.

---

JsonNotifier

Приложение построено по принципу microkernel+plugins. Как ядро выступает Scheduler, как плагины - те или иные задачи/таски, которые регистрируются в скедулере до его запуска. Задача это интерфейс с несколькими методами, в т.ч. .add_dependency(), .run(), cleanup(). При старте приложения скедулер запускает все зарегистрированные таски через run, при выходе - чистит через cleanup.

[https://gist.github.com/A1essandr0/599521c3acd4f3ad1f176578e7c08d20](https://gist.github.com/A1essandr0/599521c3acd4f3ad1f176578e7c08d20)

В самом простом виде плагинов два, webserver и json_notifier, в которые инжектятся несколько инфраструктурных зависимостей / репозиториев. 

Webserver обслуживает несколько служебных эндпоинтов. 

Json_notifier выполняет довольно навороченную логику по опросу множества серверов, затем по формированию сводного отчета (что выделено в юзкейс ReportBuilder и сущность ConsolidatedReport), затем отправляет отчет в Телеграм. Опрос также можно вынести как юзкейс.

Еще один сервис, SasorkUserDataUploader написан довольно похоже, и по идее мог быть оформлен как несколько плагинов для Scheduler, со своими юзкейсами.

---

Выводы и предложения

Вывожу: для роста и развития разработчику нужно

- знать/любить/пробовать разные архитектуры
- самому писать с нуля самые разные вещи, не полагаясь на фреймворки
- представлять любое приложение конкуррентным
- не бояться больших/монолитных приложений, одолевать сложность

Предлагаю:

- перестать бездумно лепить всюду микросервисы
- сделать для начала единый Collector для всего, что приходит в нашу систему извне